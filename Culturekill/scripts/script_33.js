self.__next_f.push([1,"import * as THREE from 'three';\nimport { scene } from 'renderer';\n\nconst PARTICLE_COUNT = 500;\nconst particles = [];\nlet particleIndex = 0;\n\n// Use a single geometry and material for all particles for better performance\nconst particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);\nconst particleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Dark red for a \"blood\" effect\n\nconst gravity = new THREE.Vector3(0, -9.8, 0);\n\nexport function setupParticles() {\n    for (let i = 0; i \u003c PARTICLE_COUNT; i++) {\n        const particle = new THREE.Mesh(particleGeometry, particleMaterial);\n        particle.visible = false;\n        scene.add(particle);\n        particles.push({\n            mesh: particle,\n            velocity: new THREE.Vector3(),\n            lifetime: 0,\n        });\n    }\n}\n\nexport function createExplosion(position, initialVelocity = new THREE.Vector3()) {\n    const explosionParticles = 20; // Number of particles per explosion\n    const explosionSpeed = 5;\n    for (let i = 0; i \u003c explosionParticles; i++) {\n        // Reuse particles from the pool\n        const p = particles[particleIndex];\n        \n        p.mesh.position.copy(position);\n        p.velocity.set(\n            (Math.random() - 0.5) * explosionSpeed,\n            (Math.random()) * explosionSpeed, // Give them an upward thrust\n            (Math.random() - 0.5) * explosionSpeed\n        );\n        p.velocity.addScaledVector(initialVelocity, 0.25); // Inherit 25% of the impact velocity\n        p.lifetime = Math.random() * 1.5 + 0.5; // Lifetime between 0.5 and 2 seconds\n        p.mesh.visible = true;\n        p.mesh.scale.set(1, 1, 1); // Reset scale\n\n        particleIndex = (particleIndex + 1) % PARTICLE_COUNT;\n    }\n}\n\nexport function updateParticles(dt) {\n    for (const p of particles) {\n        if (p.lifetime \u003e 0) {\n            p.lifetime -= dt;\n\n            if (p.lifetime \u003c= 0) {\n                p.mesh.visible = false;\n            } else {\n                // Apply physics\n                p.velocity.addScaledVector(gravity, dt);\n                p.mesh.position.addScaledVector(p.velocity, dt);\n\n                // Fade out effect by scaling down\n                const scale = Math.max(0, p.lifetime / 1.5); // Ensure scale is not negative\n                p.mesh.scale.set(scale, scale, scale);\n            }\n        }\n    }\n}"])