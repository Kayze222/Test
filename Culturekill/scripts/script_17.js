self.__next_f.push([1,"import * as THREE from 'three';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { scene, camera } from 'renderer';\nimport { state } from 'state';\nimport { Capsule } from 'three/addons/math/Capsule.js';\nimport { playPlayerDamageSound } from 'audio';\nconst ZOMBIE_URL = 'https://play.rosebud.ai/assets/Zombie.glb?B4VO';\nlet zombieModel = null;\nexport const activeZombies = [];\nconst SPAWN_INTERVAL = 1.5; // Initial spawn interval in seconds\nlet spawnTimer = SPAWN_INTERVAL;\nexport function setupZombies() {\n    const loader = new GLTFLoader();\n    loader.load(ZOMBIE_URL, (gltf) =\u003e {\n        zombieModel = gltf.scene;\n        zombieModel.traverse(child =\u003e {\n            if (child.isMesh) {\n                child.castShadow = true;\n            }\n        });\n        console.log('Zombie model loaded.');\n    }, undefined, (error) =\u003e {\n        console.error('Error loading zombie model:', error);\n    });\n}\nfunction spawnZombie() {\n    if (!zombieModel || !state.physics) return;\n    const newZombieMesh = zombieModel.clone();\n    \n    // Spawn at a random position around the map\n    const radius = 40; // This is now the half-width of the spawn area\n    const x = (Math.random() - 0.5) * radius * 2; // Random x in [-40, 40]\n    const z = (Math.random() - 0.5) * radius * 2; // Random z in [-40, 40]\n    \n    // Ensure zombies don't spawn too close to the player's initial position\n    const MIN_SPAWN_DIST = 10;\n    if (Math.sqrt(x*x + z*z) \u003c MIN_SPAWN_DIST) {\n        const angle = Math.random() * Math.PI * 2;\n        newZombieMesh.position.set(\n            Math.cos(angle) * MIN_SPAWN_DIST,\n            0,\n            Math.sin(angle) * MIN_SPAWN_DIST\n        );\n    } else {\n        newZombieMesh.position.set(x, 0, z);\n    }\n    newZombieMesh.scale.set(0.5, 0.5, 0.5);\n    newZombieMesh.rotation.y = Math.random() * Math.PI * 2; // Random initial rotation\n    scene.add(newZombieMesh);\n    // Create a physics collider for the zombie\n    const collider = new Capsule(new THREE.Vector3(0, 0.4, 0), new THREE.Vector3(0, 0.5, 0.1), 0.5);\n    collider.translate(newZombieMesh.position);\n    const zombieData = {\n        mesh: newZombieMesh,\n        collider: collider,\n        velocity: new THREE.Vector3(),\n        onFloor: true,\n        helper: createCapsuleHelper(collider),\n        health: 100, // Give zombies health\n        healthBar: createHealthBar(),\n    };\n    \n    activeZombies.push(zombieData);\n    scene.add(zombieData.helper);\n}\nfunction createHealthBar() {\n    const container = document.createElement('div');\n    Object.assign(container.style, {\n        position: 'absolute',\n        width: '50px',\n        height: '5px',\n        backgroundColor: 'rgba(0,0,0,0.5)',\n        border: '1px solid black',\n        borderRadius: '2px',\n        display: 'none', // Initially hidden\n        zIndex: '10',\n    });\n    const bar = document.createElement('div');\n    Object.assign(bar.style, {\n        width: '100%',\n        height: '100%',\n        backgroundColor: '#dc3545', // Red\n        borderRadius: '1px',\n        transition: 'width 0.1s linear',\n    });\n    container.appendChild(bar);\n    document.body.appendChild(container);\n    return { container, bar };\n}\nexport function updateZombies(dt) {\n    if (!zombieModel) return;\n    spawnTimer -= dt;\n    if (spawnTimer \u003c= 0) {\n        spawnZombie();\n        const scoreBonus = state.score * 0.025; // How much faster spawns get per point\n        spawnTimer = Math.max(0.25, SPAWN_INTERVAL - scoreBonus); // Increase rate as score goes up, with a cap\n    }\n    const playerPosition = state.physics.playerCollider.end;\n    const zombieMoveSpeed = 2;\n    for (const zombie of activeZombies) {\n        // --- Health Bar Update ---\n        const screenPosition = new THREE.Vector3();\n        const healthBarHeightOffset = 1.5; // Position the bar above the zombie's head\n        screenPosition.copy(zombie.mesh.position).y += healthBarHeightOffset;\n        screenPosition.project(camera); // Project 3D position to 2D screen space\n        // Only show if the zombie is in front of the camera\n        if (screenPosition.z \u003c 1) {\n            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;\n            const y = (screenPosition.y * -0.5 + 0.5) * window.innerHeight;\n            zombie.healthBar.container.style.display = 'block';\n            zombie.healthBar.container.style.left = `${x - 25}px`; // Center the bar\n            zombie.healthBar.container.style.top = `${y}px`;\n            const healthPercentage = Math.max(0, (zombie.health / 100) * 100);\n            zombie.healthBar.bar.style.width = `${healthPercentage}%`;\n        } else {\n            zombie.healthBar.container.style.display = 'none';\n        }\n        const direction = playerPosition.clone().sub(zombie.mesh.position).normalize();\n        zombie.velocity.x = direction.x * zombieMoveSpeed;\n        zombie.velocity.z = direction.z * zombieMoveSpeed;\n        zombie.mesh.lookAt(playerPosition.x, zombie.mesh.position.y, playerPosition.z);\n        let damping = Math.exp(-4 * dt) - 1;\n        if (!zombie.onFloor) {\n            zombie.velocity.y -= state.physics.GRAVITY * dt;\n            damping *= 0.1;\n        }\n        zombie.velocity.addScaledVector(zombie.velocity, damping);\n        const deltaPos = zombie.velocity.clone().multiplyScalar(dt);\n        zombie.collider.translate(deltaPos);\n        const res = state.physics.worldOctree.capsuleIntersect(zombie.collider);\n        zombie.onFloor = false;\n        if (res) {\n            zombie.onFloor = res.normal.y \u003e 0;\n            if (!zombie.onFloor) {\n                zombie.velocity.addScaledVector(res.normal, -res.normal.dot(zombie.velocity));\n            }\n            if (res.depth \u003e= 1e-10) {\n                zombie.collider.translate(res.normal.multiplyScalar(res.depth));\n            }\n        }\n        \n        zombie.mesh.position.copy(zombie.collider.start).add(new THREE.Vector3(0, 0, 0));\n        \n        const capsuleHeight = zombie.collider.end.y - zombie.collider.start.y;\n        zombie.helper.position.copy(zombie.collider.start);\n        zombie.helper.position.y += capsuleHeight / 2;\n        const playerCollider = state.physics.playerCollider;\n        const collisionDist = zombie.collider.radius + playerCollider.radius;\n        const actualDist = zombie.collider.end.distanceTo(playerCollider.end);\n        if (actualDist \u003c collisionDist) {\n            const now = performance.now() / 1000;\n            // Check if cooldown has passed\n            if (now - state.lastDamageTime \u003e state.damageCooldown) {\n                state.playerHealth -= 15; // Player takes 15 damage\n                state.lastDamageTime = now; // Reset cooldown timer\n                state.damageFlash = 0.5; // Trigger the flash effect\n                playPlayerDamageSound(); // Play damage sound\n                \n                // Clamp health to 0\n                if (state.playerHealth \u003c 0) {\n                    state.playerHealth = 0;\n                }\n                \n                // Check for game over\n                if (state.playerHealth \u003c= 0) {\n                    state.isGameOver = true;\n                }\n            }\n        }\n    }\n}\nfunction createCapsuleHelper(capsule) {\n    const helper = new THREE.Group();\n    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });\n    const radius = capsule.radius;\n    const cylinderHeight = capsule.end.y - capsule.start.y;\n    // Cylinder\n    const cylinder = new THREE.Mesh(\n        new THREE.CylinderGeometry(radius, radius, cylinderHeight, 8),\n        material\n    );\n    cylinder.position.y = cylinderHeight / 2;\n    // Spheres\n    const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(radius, 8, 8), material);\n    const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(radius, 8, 8), material);\n    sphere1.position.y = cylinderHeight;\n    helper.add(cylinder, sphere1, sphere2);\n    helper.visible = false; // Make helper invisible by default\n    return helper;\n}"])