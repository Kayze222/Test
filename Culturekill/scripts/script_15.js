self.__next_f.push([1,"import { state } from 'state'; // Import state to check for jetpack\nimport * as THREE from 'three';\nimport { Octree } from 'three/addons/math/Octree.js';\nimport { Capsule } from 'three/addons/math/Capsule.js';\n\nexport class SimplePhysics {\n  constructor(o={}){\n    this.GRAVITY=o.gravity??30;\n    this.STEPS_PER_FRAME=o.stepsPerFrame??5;\n    this.worldOctree=new Octree();\n    this.vector1=new THREE.Vector3();\n    this.vector2=new THREE.Vector3();\n    this.vector3=new THREE.Vector3();\n    this.playerCollider=null;\n    this.playerVelocity=new THREE.Vector3();\n    this.playerDirection=new THREE.Vector3();\n    this.playerOnFloor=false;\n    this.playerSpeed = 25; // Base speed on floor\n    this.spheres=[];\n    this.camera=o.camera??null;\n    this._key={};\n  }\n  initPlayer(){\n    this.playerCollider=new Capsule(new THREE.Vector3(0,0.35,0),new THREE.Vector3(0,1,0),0.35);\n  }\n  setKeyMap(map){ this._key=map; }\n  addSphere(mesh,pos,r){\n    const s={mesh,collider:new THREE.Sphere(pos,r),velocity:new THREE.Vector3()};\n    this.spheres.push(s);return s;\n  }\n  loadEnvironment(obj){ this.worldOctree.fromGraphNode(obj); return this; }\n  getForwardVector(){ if(!this.camera) return new THREE.Vector3(); this.camera.getWorldDirection(this.playerDirection);this.playerDirection.y=0;return this.playerDirection.normalize(); }\n  getSideVector(){ if(!this.camera) return new THREE.Vector3(); this.camera.getWorldDirection(this.playerDirection);this.playerDirection.y=0;this.playerDirection.normalize();return this.playerDirection.cross(this.camera.up); }\n  controls(dt){\n    const k=this._key; const speed=dt*(this.playerOnFloor ? this.playerSpeed : this.playerSpeed * 0.4);\n    // Mouse move is handled directly in main.js now\n    if(k.KeyW) this.playerVelocity.add(this.getForwardVector().multiplyScalar(speed));\n    if(k.KeyS) this.playerVelocity.add(this.getForwardVector().multiplyScalar(-speed));\n    if(k.KeyA) this.playerVelocity.add(this.getSideVector().multiplyScalar(-speed));\n    if(k.KeyD) this.playerVelocity.add(this.getSideVector().multiplyScalar(speed));\n    if (state.jetpackUnlocked \u0026\u0026 k.Space \u0026\u0026 state.jetpackFuel \u003e 0) {\n        // Jetpack flight\n        this.playerVelocity.y += 45 * dt; // Apply continuous upward force\n        if (this.playerVelocity.y \u003e 10) this.playerVelocity.y = 10; // Cap vertical speed\n        state.jetpackFuel -= 35 * dt; // Consume fuel over time\n        this.playerOnFloor = false; // Player is flying\n    } else if (this.playerOnFloor \u0026\u0026 k.Space) {\n        // Normal jump if jetpack isn't used or is out of fuel\n        this.playerVelocity.y = 15;\n    }\n  }\n  updatePlayer(dt){\n    let damping=Math.exp(-4*dt)-1;\n    if(!this.playerOnFloor){ this.playerVelocity.y-=this.GRAVITY*dt; damping*=0.1; }\n    this.playerVelocity.addScaledVector(this.playerVelocity,damping);\n    const deltaPos=this.playerVelocity.clone().multiplyScalar(dt);\n    this.playerCollider.translate(deltaPos);\n    // collisions\n    const res=this.worldOctree.capsuleIntersect(this.playerCollider);\n    this.playerOnFloor=false;\n    if(res){\n      this.playerOnFloor=res.normal.y\u003e0;\n      if(!this.playerOnFloor){ this.playerVelocity.addScaledVector(res.normal,-res.normal.dot(this.playerVelocity)); }\n      // Avoid penetration adjustments if depth is negligible to prevent jitter\n      if(res.depth \u003e= 1e-10){ this.playerCollider.translate(res.normal.multiplyScalar(res.depth)); }\n    }\n  }\n  updateSpheres(dt, collisionCallback) {\n    for(const s of this.spheres) {\n      if (s.collider.center.y \u003c -90) continue; // Skip inactive spheres\n      s.collider.center.addScaledVector(s.velocity, dt);\n      // Perform custom collision check (e.g., vs zombies) before world collision\n      if (collisionCallback) {\n        collisionCallback();\n      }\n      // If sphere is still active after custom check, then check against world\n      if (s.collider.center.y \u003e -90) {\n        const res = this.worldOctree.sphereIntersect(s.collider);\n        if (res) {\n          s.collider.center.set(0, -100, 0);\n          s.velocity.set(0, 0, 0);\n        }\n      }\n      \n      const damp = Math.exp(-1.5 * dt) - 1;\n      s.velocity.addScaledVector(s.velocity, damp);\n    }\n    for(const s of this.spheres) {\n        // Ghost Tracer: Smoothly move the visible mesh to the physics collider's position\n        s.mesh.position.lerp(s.collider.center, 0.3);\n        // Orient the laser mesh to point in the direction of its velocity\n        if (s.velocity.lengthSq() \u003e 0.001) { // Only update if moving\n            s.mesh.lookAt(s.mesh.position.clone().add(s.velocity));\n        }\n    }\n  }\n  teleportPlayerIfOob(){ if(!this.camera) return; if(this.camera.position.y\u003c=-25){ this.playerCollider.start.set(0,0.35,0);this.playerCollider.end.set(0,1,0);this.playerVelocity.set(0,0,0); this.camera.position.copy(this.playerCollider.end); this.camera.rotation.set(0,0,0); } }\n  updateStep(dt){\n    this.controls(dt);\n    this.updatePlayer(dt);\n    this.updateSpheres(dt, this.collisionCallback); // Pass callback\n    this.teleportPlayerIfOob();\n    if(this.camera) this.camera.position.copy(this.playerCollider.end);\n  }\n  updateAccum(dt, collisionCallback){\n    this.collisionCallback = collisionCallback; // Store callback for use in updateStep\n    const step = Math.min(dt, 0.1) / this.STEPS_PER_FRAME;\n    for(let i = 0; i \u003c this.STEPS_PER_FRAME; i++) this.updateStep(step);\n  }\n  /**\n   * Throws a sphere from a specified origin and direction.\n   * @param {number} idx Index of the sphere to throw.\n   * @param {number} mouseDt Time difference for impulse calculation.\n   * @param {THREE.Vector3} origin The world-space position to throw from.\n   * @param {THREE.Vector3} direction The world-space direction to throw in.\n   */\n  throwBall(idx, mouseDt, origin, direction) {\n    if (idx \u003c 0 || idx \u003e= this.spheres.length) return idx; // Bounds check\n    if (!origin || !direction) return idx; // Need origin and direction\n    const s = this.spheres[idx];\n    // Set the sphere's starting position slightly in front of the origin\n    s.collider.center.copy(origin).addScaledVector(direction, 0.2); // Start slightly ahead\n    // Calculate impulse safely\n    const timeDiff = Math.max(0, mouseDt); // Ensure mouseDt is non-negative\n    const imp = 200; // Increased velocity for laser-like effect\n    // Set velocity based on the provided direction and impulse\n    // Add a bit of the player's velocity so movement affects throws slightly\n    s.velocity.copy(direction).multiplyScalar(imp).addScaledVector(this.playerVelocity, 0.1);\n    return idx;\n  }\n}"])