self.__next_f.push([1,"import * as THREE from 'three';\nimport { state } from 'state';\nimport { SimplePhysics } from 'SimplePhysics';\nimport { camera, scene } from 'renderer'; // Import camera and scene\nimport { animateBlowback, gunModel } from 'gun'; // Import blowback animation function AND gunModel\nimport { swordModel, triggerSwordSwing } from 'sword'; // Import sword logic\nimport { activeZombies } from 'zombie'; // Import zombies to check for hits\nimport { createExplosion } from 'particles'; // Import the explosion function\nimport { playGunshotSound, playExplosionSound } from 'audio'; // Import sound functions\nimport { checkKillCountForUpgrade } from 'upgrades';\nconst NUM_SPHERES = 100, RADIUS = 0.05;\nlet physics; // Declare physics instance variable\nlet sphereIdx = 0;\nlet mouseDownTime = 0;\nconst originVector = new THREE.Vector3(); // Temporary vector for origin calculation\nconst directionVector = new THREE.Vector3(); // Temporary vector for direction calculation\nconst tempVector = new THREE.Vector3();\nexport function setupPhysicsSystem() {\n  physics = new SimplePhysics({ gravity: 30, stepsPerFrame: 5, camera }); // Initialize physics here\n  state.physics = physics; // Assign to global state\n  physics.initPlayer();\n  physics.setKeyMap(state.key);\n\n  // create laser projectiles\n  const laserLength = 1.5;\n  const geom = new THREE.CylinderGeometry(RADIUS, RADIUS, laserLength, 8);\n  geom.rotateX(Math.PI / 2); // Orient cylinder to point along Z-axis\n  const mat = new THREE.MeshLambertMaterial({\n      color: 0x00ffff, // Cyan color\n      emissive: 0x00ffff, // Make it glow\n      emissiveIntensity: 2,\n  });\n  for (let i = 0; i \u003c NUM_SPHERES; i++) {\n    const m = new THREE.Mesh(geom, mat);\n    m.castShadow = false; // Lasers don't need to cast shadows\n    m.receiveShadow = false;\n    scene.add(m);\n    // The physics collider is still a sphere for simplicity and efficiency\n    physics.addSphere(m, new THREE.Vector3(0, -100, 0), RADIUS);\n  }\n\n  // mouse throw listener\n  const canvas = document.getElementById('renderDiv'); // Use container div\n  canvas.addEventListener('mousedown', () =\u003e { mouseDownTime = performance.now(); });\n  document.addEventListener('mouseup', () =\u003e { // Listen on document for mouseup\n    if (document.pointerLockElement \u0026\u0026 physics \u0026\u0026 gunModel \u0026\u0026 state.activeWeapon === 'gun') {\n      if (state.ammo \u003c= 0 \u0026\u0026 !state.infiniteAmmoActive) {\n        // Maybe play an \"empty clip\" sound here in the future\n        return;\n      }\n      if (!state.infiniteAmmoActive) {\n          state.ammo--; // Decrement ammo\n      }\n      // 1. ACCURATE AIM: Get the direction the camera is facing.\n      camera.getWorldDirection(directionVector);\n      // 2. PHYSICS: The \"real\" projectile starts from the camera's center for perfect accuracy.\n      originVector.copy(camera.position);\n      // The collider starts at the camera's position for accurate hit detection.\n      const s = physics.spheres[sphereIdx];\n      s.collider.center.copy(originVector);\n      \n      physics.throwBall(sphereIdx, performance.now() - mouseDownTime, originVector, directionVector);\n      \n      // 3. VISUALS: The visible tracer mesh *appears* to start at the gun's muzzle.\n      // We calculate the muzzle's world position and place the mesh there.\n      const muzzleOffset = new THREE.Vector3(0, 0.05, -0.4); // Use same offset as muzzle flash\n      gunModel.localToWorld(muzzleOffset);\n      s.mesh.position.copy(muzzleOffset); // The mesh starts at the muzzle.\n      \n      physics.spheres[sphereIdx].mesh.scale.setScalar(state.bulletSize); // Apply bullet size upgrade\n      animateBlowback(); // Trigger the blowback animation\n      playGunshotSound(); // Play the gunshot sound\n      sphereIdx = (sphereIdx + 1) % NUM_SPHERES;\n    } else if (document.pointerLockElement \u0026\u0026 swordModel \u0026\u0026 state.activeWeapon === 'sword') {\n        if (triggerSwordSwing()) {\n            // Check for zombie hits after a short delay to match the animation\n            setTimeout(checkSwordZombieCollisions, 100);\n        }\n    }\n  });\n\n  return physics; // Return the instance if needed elsewhere\n}\n\nexport function updatePhysicsSystem(dt) {\n  if (physics) { // Check if physics is initialized before updating\n    physics.updateAccum(dt, checkSphereZombieCollisions); // Pass collision check as callback\n  }\n}\nfunction checkSphereZombieCollisions() {\n    if (!physics) return;\n    for (const sphere of physics.spheres) {\n        if (sphere.collider.center.y \u003c -90) continue; // Skip inactive spheres\n        for (let i = activeZombies.length - 1; i \u003e= 0; i--) {\n            const zombie = activeZombies[i];\n            const dist = sphere.collider.center.distanceTo(zombie.collider.end);\n            const sphereRadius = sphere.collider.radius * sphere.mesh.scale.x; // Use scaled radius for hit check\n            if (dist \u003c zombie.collider.radius + sphereRadius) {\n                // HIT!\n                zombie.health -= state.gunDamage;\n                createExplosion(sphere.collider.center, sphere.velocity); // Pass bullet velocity to particles\n                playExplosionSound(); // Play explosion sound\n                if (zombie.health \u003c= 0) {\n                    document.body.removeChild(zombie.healthBar.container);\n                    scene.remove(zombie.mesh);\n                    scene.remove(zombie.helper);\n                    activeZombies.splice(i, 1);\n                    state.score++;\n                    checkKillCountForUpgrade(); // Check if we should trigger an upgrade\n                    const scoreElement = document.getElementById('score-display');\n                    if (scoreElement) {\n                        scoreElement.textContent = `Score: ${state.score}`;\n                    }\n                }\n                \n                // Deactivate sphere so it doesn't hit other things\n                sphere.collider.center.set(0, -100, 0);\n                sphere.velocity.set(0, 0, 0);\n                break; // Exit inner loop once a hit is registered for this sphere\n            }\n        }\n    }\n}\nfunction checkSwordZombieCollisions() {\n    if (!physics) return;\n    const MELEE_RANGE = 2.5;\n    const MELEE_ARC_DEGREES = 90;\n    const MELEE_DAMAGE = 50;\n    const playerPosition = physics.playerCollider.end;\n    camera.getWorldDirection(directionVector); // Player's forward direction\n    for (let i = activeZombies.length - 1; i \u003e= 0; i--) {\n        const zombie = activeZombies[i];\n        \n        // 1. Check distance\n        const dist = playerPosition.distanceTo(zombie.collider.end);\n        if (dist \u003e MELEE_RANGE) continue;\n        // 2. Check angle\n        const zombieDirection = tempVector.subVectors(zombie.collider.end, playerPosition).normalize();\n        const angle = directionVector.angleTo(zombieDirection) * (180 / Math.PI);\n        if (angle \u003e MELEE_ARC_DEGREES / 2) continue;\n        \n        // HIT!\n        zombie.health -= MELEE_DAMAGE; // Assuming zombies have health now\n        \n        // Create a directional blood splatter for sword hits\n        const splatterDirection = tempVector.subVectors(zombie.collider.end, playerPosition).normalize();\n        createExplosion(zombie.collider.end, splatterDirection.multiplyScalar(5));\n        playExplosionSound(); // Maybe a different \"slice\" sound later\n        if (zombie.health \u003c= 0) {\n            document.body.removeChild(zombie.healthBar.container);\n            scene.remove(zombie.mesh);\n            scene.remove(zombie.helper);\n            activeZombies.splice(i, 1);\n            state.score++;\n            checkKillCountForUpgrade(); // Check if we should trigger an upgrade\n            const scoreElement = document.getElementById('score-display');\n            if (scoreElement) {\n                scoreElement.textContent = `Score: ${state.score}`;\n            }\n        }\n    }\n}"])