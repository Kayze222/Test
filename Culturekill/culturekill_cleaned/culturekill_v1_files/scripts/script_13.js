self.__next_f.push([1,"import * as THREE from 'three';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { camera, scene } from 'renderer'; // Import camera and scene\nimport { damp } from 'maath/easing'; // Import damp for smooth animation\nexport let gunModel = null; // Export gunModel\nconst GUN_URL = 'https://play.rosebud.ai/assets/revolver.glb?SSQD';\nconst originalPosition = new THREE.Vector3(0.25, -0.3, -0.5); // Position: right, down, forward\nlet blowbackActive = false;\nlet blowbackStartTime = 0;\nconst BLOWBACK_DISTANCE = 0.15; // How far back it moves\nconst BLOWBACK_DURATION = 0.1; // Time to move back\nconst RETURN_DURATION = 0.3; // Time to return to original position\nlet muzzleFlashLight;\nconst FLASH_INTENSITY = 50; // Brightness of the flash\nconst FLASH_DURATION = 0.05; // How long the flash stays at max intensity\nconst FLASH_FADE_DURATION = 0.1; // How long it takes to fade out\nexport function loadGun() {\n    const loader = new GLTFLoader();\n    // Load the GLB model\n    loader.load(GUN_URL, (gltf) =\u003e {\n        gunModel = gltf.scene;\n        // Apply texture and configure materials\n        gunModel.traverse((child) =\u003e {\n            if (child.isMesh) {\n                child.castShadow = true; // Enable shadows if desired\n                // The new model has its own materials, so we don't need to apply custom ones.\n                // We can still tweak them if needed, e.g., child.material.metalness = 0.9;\n            }\n        });\n        // Scale and position the gun relative to the camera\n        gunModel.scale.set(1, 1, 1); // Made it slightly smaller\n        gunModel.position.copy(originalPosition); // Use stored original position\n        gunModel.rotation.set(0, Math.PI * -0.5, 0); // Point mostly forward\n        // Create Muzzle Flash Light\n        muzzleFlashLight = new THREE.PointLight(0xffa500, 0, 5, 2); // Orange-ish, intensity 0, distance 5, decay 2\n        muzzleFlashLight.position.set(0, 0.05, -0.4); // Position at the barrel end relative to the gun model\n        gunModel.add(muzzleFlashLight); // Add light as child of the gun\n        // Attach the gun model directly to the camera\n        camera.add(gunModel);\n        // Add the camera (which now contains the gun) to the main scene\n        // Note: The camera is usually already added, but ensure it is.\n        if (!scene.children.includes(camera)) {\n             scene.add(camera); // Ensure camera is part of the scene graph\n        }\n        console.log('Gun model loaded and attached to camera.');\n    }, undefined, (error) =\u003e {\n        console.error('Error loading gun model:', error);\n    });\n}\n\n// Function to trigger the blowback animation\nexport function animateBlowback() {\n    if (!gunModel) return; // Only proceed if gun exists\n    // Always restart the animation timer and state\n    blowbackActive = true;\n    blowbackStartTime = performance.now() / 1000; // Reset start time in seconds\n    // Always reset muzzle flash\n    if (muzzleFlashLight) {\n        muzzleFlashLight.intensity = FLASH_INTENSITY;\n    }\n}\n// Function to update the gun's position and muzzle flash animation\nexport function updateGunAnimation(dt) {\n    const now = performance.now() / 1000;\n    const elapsedTime = now - blowbackStartTime;\n    // --- Blowback Animation ---\n    if (gunModel \u0026\u0026 blowbackActive) {\n        const targetZ = originalPosition.z + BLOWBACK_DISTANCE;\n    if (elapsedTime \u003c= BLOWBACK_DURATION) {\n        // Move backward\n        damp(gunModel.position, 'z', targetZ, BLOWBACK_DURATION / 2, dt); // Use damp for smoother transition\n    } else if (elapsedTime \u003c= BLOWBACK_DURATION + RETURN_DURATION) {\n        // Return to original position - Adjust the lambda (smoothing factor) for a smoother return\n        damp(gunModel.position, 'z', originalPosition.z, RETURN_DURATION * 0.25, dt); // Made lambda smaller for more smoothing\n    } else {\n        // Animation finished\n            gunModel.position.z = originalPosition.z; // Ensure it's exactly back\n            blowbackActive = false;\n        }\n    }\n    // --- Muzzle Flash Fade ---\n    if (muzzleFlashLight \u0026\u0026 muzzleFlashLight.intensity \u003e 0) {\n        const flashElapsedTime = now - blowbackStartTime; // Use the same timer for simplicity\n        if (flashElapsedTime \u003e FLASH_DURATION) {\n            // Start fading after the initial flash duration\n            const fadeProgress = Math.min(1, (flashElapsedTime - FLASH_DURATION) / FLASH_FADE_DURATION);\n            muzzleFlashLight.intensity = THREE.MathUtils.lerp(FLASH_INTENSITY, 0, fadeProgress);\n        }\n        // Ensure intensity is exactly 0 after fade duration\n        if (flashElapsedTime \u003e= FLASH_DURATION + FLASH_FADE_DURATION) {\n             muzzleFlashLight.intensity = 0;\n        }\n    }\n}"])