self.__next_f.push([1,"import * as THREE from 'three';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { camera } from 'renderer';\nimport { state } from 'state';\nimport { dampE, dampQ } from 'maath/easing';\nimport { playSwordSwingSound } from 'audio';\nexport let swordModel = null;\nconst SWORD_URL = 'https://play.rosebud.ai/assets/katana.glb?HNbg';\nconst originalPosition = new THREE.Vector3(0.2, -0.2, -0.5); // Adjusted for new scale\nconst originalRotation = new THREE.Euler(-0, Math.PI * -0.5, 0); // Adjusted for new model\n// --- Swing Animation ---\n// Define rotations for a downward slash\nconst swingStartRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI * 0.0, Math.PI * 0, 0));\nconst swingEndRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI * -0.5, -Math.PI * 0, 0));\nlet targetQuaternion = new THREE.Quaternion().setFromEuler(originalRotation);\nconst SWING_ANIMATION_SPEED = 0.08;\nexport function triggerSwordSwing() {\n    const now = performance.now() / 1000;\n    if (now - state.lastSwordSwingTime \u003c state.swordSwingCooldown) return false;\n    state.isSwordSwinging = true;\n    state.lastSwordSwingTime = now;\n    playSwordSwingSound();\n    \n    // Set the initial target for the swing\n    targetQuaternion.copy(swingStartRotation);\n    \n    // After a short delay, set the end target\n    setTimeout(() =\u003e {\n        if(state.isSwordSwinging) targetQuaternion.copy(swingEndRotation);\n    }, 25);\n    // After the swing duration, mark it as finished\n    setTimeout(() =\u003e {\n        state.isSwordSwinging = false;\n    }, state.swordSwingCooldown * 1000 * 0.8); // End animation slightly before cooldown is up\n    return true; // Swing was successful\n}\nexport function loadSword() {\n    const loader = new GLTFLoader();\n    loader.load(SWORD_URL, (gltf) =\u003e {\n        swordModel = gltf.scene;\n\n        swordModel.traverse((child) =\u003e {\n            if (child.isMesh) {\n                child.castShadow = true;\n                // Use the model's own materials, but ensure they can cast shadows\n                child.material.metalness = 0.8;\n                child.material.roughness = 0.4;\n            }\n        });\n\n        // Scale and position the sword relative to the camera\n        swordModel.scale.set(0.05, 0.05, 0.05);\n        swordModel.position.copy(originalPosition);\n        swordModel.rotation.copy(originalRotation);\n\n        // Attach the sword model directly to the camera\n        camera.add(swordModel);\n\n        console.log('Sword model loaded and attached to camera.');\n    }, undefined, (error) =\u003e {\n        console.error('Error loading sword model:', error);\n    });\n}\n\n// Update function for animations\nexport function updateSwordAnimation(dt) {\n    if (!swordModel) return;\n    if (state.isSwordSwinging) {\n        // Smoothly swing the sword towards the current target rotation\n        dampQ(swordModel.quaternion, targetQuaternion, SWING_ANIMATION_SPEED, dt);\n    } else {\n        // When not swinging, return to original rotation and apply bobbing\n        targetQuaternion.setFromEuler(originalRotation); // Ensure target is the idle rotation\n        dampQ(swordModel.quaternion, targetQuaternion, SWING_ANIMATION_SPEED, dt);\n        // Gentle bobbing motion for idle state\n        const time = performance.now() * 0.001; // Convert time to seconds\n        const bobbleY = Math.sin(time * 2) * 0.02;\n        const bobbleX = Math.sin(time * 1.5) * 0.05;\n        \n        // Apply bobble on top of base position/rotation\n        swordModel.position.y = originalPosition.y + bobbleY;\n        \n        // This is tricky with quaternions, let's keep it simple for now and maybe add later if needed.\n        // It might be better to add the bobble to a parent container instead.\n    }\n}"])